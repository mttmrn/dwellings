{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n\n  if (obj != null) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  var isLastCaseWithConsequent = true;\n\n  for (var i = cases.length - 1; i >= 0; i--) {\n    var switchCase = cases[i];\n    var consequent = switchCase.get(\"consequent\");\n    var breakStatement = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      findBreak: for (var _iterator = consequent[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var statement = _step.value;\n\n        if (statement.isBlockStatement()) {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = statement.get(\"body\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var statementInBlock = _step2.value;\n\n              if (statementInBlock.isBreakStatement()) {\n                breakStatement = statementInBlock;\n                break findBreak;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        } else if (statement.isBreakStatement()) {\n          breakStatement = statement;\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      var prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      (function () {\n        var statementFinder = function statementFinder(statement) {\n          return !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n        };\n\n        var hasConsequent = consequent.some(statementFinder);\n\n        if (hasConsequent) {\n          paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n          isLastCaseWithConsequent = false;\n        }\n      })();\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  var paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  });\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  var _key = this.key;\n  var sibling = this.getSibling(++_key);\n  var siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  var _key = this.key;\n  var sibling = this.getSibling(--_key);\n  var siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context) {\n  if (context === true) context = this.context;\n  var parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  var _this = this;\n\n  var node = this.node;\n  var container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map(function (_, i) {\n      return _index.default.get({\n        listKey: key,\n        parentPath: _this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  var path = this;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = parts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var part = _step3.value;\n\n      if (part === \".\") {\n        path = path.parentPath;\n      } else {\n        if (Array.isArray(path)) {\n          path = path[part];\n        } else {\n          path = path.get(part, context);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t().getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t().getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths() {\n  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var path = this;\n  var search = [].concat(path);\n  var ids = Object.create(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    var keys = t().getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        var _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      var declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","map":null,"metadata":{},"sourceType":"script"}