{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/mattmoran/Desktop/VS Code/dwellings/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cloneDeep() {\n  var data = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\n  _cloneDeep = function _cloneDeep() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  var data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _parser() {\n  var data = require(\"@babel/parser\");\n\n  _parser = function _parser() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  var data = require(\"@babel/code-frame\");\n\n  _codeFrame = function _codeFrame() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = _interopRequireDefault(require(\"./file/file\"));\n\nvar _missingPluginHelper = _interopRequireDefault(require(\"./util/missing-plugin-helper\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n\n  if (obj != null) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = (0, _debug().default)(\"babel:transform:file\");\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  code = \"\".concat(code || \"\");\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = t().file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    ast = (0, _cloneDeep().default)(ast);\n  } else {\n    ast = parser(pluginPasses, options, code);\n  }\n\n  var inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      var lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      var _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && _lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromMapFileComment(_lastComment, _path().default.dirname(options.filename));\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (_lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code: code,\n    ast: ast,\n    inputMap: inputMap\n  });\n}\n\nfunction parser(pluginPasses, _ref, code) {\n  var parserOpts = _ref.parserOpts,\n      _ref$highlightCode = _ref.highlightCode,\n      highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode,\n      _ref$filename = _ref.filename,\n      filename = _ref$filename === void 0 ? \"unknown\" : _ref$filename;\n\n  try {\n    var results = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var plugins = _step.value;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var plugin = _step2.value;\n            var parserOverride = plugin.parserOverride;\n\n            if (parserOverride) {\n              var ast = parserOverride(code, parserOpts, _parser().parse);\n              if (ast !== undefined) results.push(ast);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      if (typeof results[0].then === \"function\") {\n        throw new Error(\"You appear to be using an async codegen plugin, \" + \"which your current version of Babel does not support. \" + \"If you're using a published plugin, you may need to upgrade \" + \"your @babel/core version.\");\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    var loc = err.loc,\n        missingPlugin = err.missingPlugin;\n\n    if (loc) {\n      var codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode: highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = \"\".concat(filename, \": \") + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = \"\".concat(filename, \": \").concat(err.message, \"\\n\\n\") + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}\n\nvar INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nvar EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+?)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(function (_ref2) {\n      var value = _ref2.value;\n\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  var lastComment = null;\n  t().traverseFast(ast, function (node) {\n    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);\n\n    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);\n\n    node.leadingComments = _extractCommentsFromL2[0];\n    lastComment = _extractCommentsFromL2[1];\n\n    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);\n\n    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);\n\n    node.innerComments = _extractCommentsFromL4[0];\n    lastComment = _extractCommentsFromL4[1];\n\n    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);\n\n    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);\n\n    node.trailingComments = _extractCommentsFromL6[0];\n    lastComment = _extractCommentsFromL6[1];\n  });\n  return lastComment;\n}","map":null,"metadata":{},"sourceType":"script"}